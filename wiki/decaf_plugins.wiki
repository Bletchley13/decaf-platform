=Tutorials on Developing Plugins=
==1 Introduction==
DECAF provides many callback interfaces for developers to write powerful plugins to instrument the execution of the guest operating system.  It invokes the callback at runtime,so you can dynamically enable or disable,register or unregister callbacks. With these callback interfaces, you can retrieve OS-level semantics including process ,system api,keystroke,network,etc, completely  outside  the guest operating system.This manual provides some basic knowledge on developing plugins for DECAF.

==2 Sample plugin==

The following code is a sample plugin. With this plugin, you can specify a process you wanna trace and print out the process name when the process starts. It's small but complete.

After DECAF loads the plugin, it will call *init_plugin(void)* first. You can use *plugin_interface_t*(DECAF_main.h) to define the behaviors of plugins. But the most important thing is to specify the *plugin_cleanup* interface.We usually free the resources allocated for this plugin using this interface.If we do not do this or do not free resources completely, DECAF may crash.Another thing you can do using *plugin_interface_t* is to define your own command for DECAF. So you can interact with your plugin at runtime.      
 
{{{
  #include "DECAF_types.h"
  #include "DECAF_main.h"
  #include "DECAF_callback.h"
  #include "DECAF_callback_common.h"
  #include "shared/procmod.h"
  #include "utils/Output.h"
  #include "DECAF_target.h"
  
  //basic stub for plugins
  static plugin_interface_t my_interface;
  static DECAF_Handle processbegin_handle = DECAF_NULL_HANDLE;
  
  char targetname[511];
  
  /*
  * This callback is invoked when a new process starts in the guest OS.
  */
  static void my_loadmainmodule_callback(procmod_Callback_Params* params)
  {
    if(strcmp(params->lmm.name,targetname)==0)
  	  DECAF_printf("Process %s you spcecified starts \n",params->lmm.name);
  }
  /*
   * Handler to implement the command monitor_proc.
   */
  
  void do_monitor_proc(Monitor* mon, const QDict* qdict)
  {
  	/*
  	 * Copy the name of the process to be monitored to targetname.
  	 */
    if ((qdict != NULL) && (qdict_haskey(qdict, "procname"))) {
      strncpy(targetname, qdict_get_str(qdict, "procname"), 512);
    }
  targetname[511] = '\0';
  }
  
  static int my_init(void)
  {
    DECAF_printf("Hello World\n");
  
    //register for process create and process remove events  
    processbegin_handle = procmod_register_callback(PROCMOD_PROCESSBEGIN_CB, &my_loadmainmodule_callback, NULL);
    if (processbegin_handle == DECAF_NULL_HANDLE)
    {
      DECAF_printf("Could not register for the create or remove proc events\n");  
    }
    return (0);
  }
  
  /*
   * This function is invoked when the plugin is unloaded.
   */
  static void my_cleanup(void)
  {
    DECAF_printf("Bye world\n");
    /*
     * Unregister for the process start and exit callbacks.
     */
    if (processbegin_handle != DECAF_NULL_HANDLE) {
      procmod_unregister_callback(PROCMOD_PROCESSBEGIN_CB, processbegin_handle);  
      processbegin_handle = DECAF_NULL_HANDLE;
    }
    } 
  /*
   * Commands supported by the plugin. Included in plugin_cmds.h
   */
  static mon_cmd_t my_term_cmds[] = {
    		{
  			.name		= "monitor_proc",
  			.args_type	= "procname:s?",
  			.mhandler.cmd	= do_monitor_proc,
  			.params		= "[procname]",
  			.help		= "Run the tests with program [procname]"
  		},
    {NULL, NULL, },
  };
  
  /*
   * This function registers the plugin_interface with DECAF.
   * The interface is used to register custom commands, let DECAF know which cleanup function to call upon plugin unload, etc,.
   */
  plugin_interface_t* init_plugin(void)
  {
    my_interface.mon_cmds = my_term_cmds;
    my_interface.plugin_cleanup = &my_cleanup;
    
    my_init();
    return (&my_interface);
  }
}}}

Now,you know the *plugin_cleanup* and *mon_cmds*. Let's talk about the sample plugin code. As you see, in the function *inint_plugin(void)*, we define our own command using *my_term_cmds*. In *my_term_cmds*, we specify the command name,command handler,command parameters and help message. You can define whatever you like following this convention. The *plugin_cleanup* is also defined by *my_cleanup*. Using *my_cleanup*, DECAF cleanup all the resources used by the plugin.

In *my_init()*, we register  *PROCMOD_PROCESSBEGIN_CB* callback and its handler *my_loadmainmodule_callback*. So when a process starts, DECAF will call *my_loadmainmodule_callback*. And from its parameters, you can get the pid,name and cr3 of the process. So you can check if it's the process you specified with monitor_proc command. If so, we print out the process name. Of course, we can do many other things.For example, we can register *DECAF_INSN_BEGIN_CB* callback and its handler at this place. And in its handler, we check if it belongs to the specified process and print out the instruction's EIP shown as following code.
{{{
  uint32_t target_cr3;
  static void my_insn_begin_callback(DECAF_Callback_Params* params)
  {
       if(params->ib.env->cr[3]==target_cr3)
	{
		DECAF_printf("EIP 0x%08x \n",params->ib.env->eip);
	}
  }
  /*
  * This callback is invoked when a new process starts in the guest OS.
  */
  static void my_loadmainmodule_callback(procmod_Callback_Params* params)
  {
    if(strcmp(params->lmm.name,targetname)==0){
  	  DECAF_printf("Process %s you spcecified starts \n",params->lmm.name);
    target_cr3=params->lmm.cr3;  
     DECAF_register_callback(DECAF_INSN_BEGIN_CB,&my_insn_begin_callback,NULL)
    }
  }


}}}

One thing you need to take care of is the third parameter of *procmod_register_callback*. If it's NULL, it means this callback will be invoked all the time. If it's a pointer pointing to 1, this callback will be invoked all the time. If it's a pointer pointing to 0, this callback is disabled. Other kind of callback registration function is also following this convention.

Now you see how to register or unregister ,enable or disable callbacks. As to the interfaces exported by DECAF to instrument the system,please see [https://code.google.com/p/decaf-platform/wiki/decaf_interfaces DECAF interfaces]

==3 Configure&Makefile==

We suggest you use configure/Makefile in the sample plugin we published in [http://code.google.com/p/decaf-platform/downloads/detail?name=decaf_plugins.tar.gz decaf_plugins.tar.gz] as a template to write your own configure/makefile. 