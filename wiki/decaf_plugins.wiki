=Tutorials on Developing Plugins=
==Introduction==
DECAF provides many callback interfaces for developers to write powerful plugins to instrument the execution of the guest operating system.  It invokes the callback at runtime,so you can dynamically enable or disable,register or unregister callbacks. With these callback interfaces, you can retrieve OS-level semantics including process ,system api,keystroke,network,etc, completely  outside  the guest operating system.This manual provides some basic knowledge on developing plugins for DECAF.

==Sample plugin==

The following code is a sample plugin. With this plugin, you can specify a process you wanna trace and print out the process name when the process starts. It's small but complete.

After DECAF loads the plugin, it will call *init_plugin(void)* first. You can use *plugin_interface_t*(DECAF_main.h) to define the behaviors of plugins. But the most important thing is to specify the *plugin_cleanup* interface.We usually free the resources allocated for this plugin using this interface.If we do not do this or do not free resources completely, DECAF may crash.Another thing you can do using *plugin_interface_t* is to define your own command for DECAF. So you can interact with your plugin at runtime.      
 
{{{
  #include "DECAF_types.h"
  #include "DECAF_main.h"
  #include "DECAF_callback.h"
  #include "DECAF_callback_common.h"
  #include "shared/procmod.h"
  #include "utils/Output.h"
  #include "DECAF_target.h"
  
  //basic stub for plugins
  static plugin_interface_t my_interface;
  static DECAF_Handle processbegin_handle = DECAF_NULL_HANDLE;
  
  char targetname[511];
  
  /*
  * This callback is invoked when a new process starts in the guest OS.
  */
  static void my_loadmainmodule_callback(procmod_Callback_Params* params)
  {
    if(strcmp(params->lmm.name,targetname)==0)
  	  DECAF_printf("Process %s you spcecified starts \n",params->lmm.name);
  }
  /*
   * Handler to implement the command monitor_proc.
   */
  
  void do_monitor_proc(Monitor* mon, const QDict* qdict)
  {
  	/*
  	 * Copy the name of the process to be monitored to targetname.
  	 */
    if ((qdict != NULL) && (qdict_haskey(qdict, "procname"))) {
      strncpy(targetname, qdict_get_str(qdict, "procname"), 512);
    }
  targetname[511] = '\0';
  }
  
  static int my_init(void)
  {
    DECAF_printf("Hello World\n");
  
    //register for process create and process remove events  
    processbegin_handle = procmod_register_callback(PROCMOD_PROCESSBEGIN_CB, &my_loadmainmodule_callback, NULL);
    if (processbegin_handle == DECAF_NULL_HANDLE)
    {
      DECAF_printf("Could not register for the create or remove proc events\n");  
    }
    return (0);
  }
  
  /*
   * This function is invoked when the plugin is unloaded.
   */
  static void my_cleanup(void)
  {
    DECAF_printf("Bye world\n");
    /*
     * Unregister for the process start and exit callbacks.
     */
    if (processbegin_handle != DECAF_NULL_HANDLE) {
      procmod_unregister_callback(PROCMOD_PROCESSBEGIN_CB, processbegin_handle);  
      processbegin_handle = DECAF_NULL_HANDLE;
    }
    } 
  /*
   * Commands supported by the plugin. Included in plugin_cmds.h
   */
  static mon_cmd_t my_term_cmds[] = {
    		{
  			.name		= "monitor_proc",
  			.args_type	= "procname:s?",
  			.mhandler.cmd	= do_monitor_proc,
  			.params		= "[procname]",
  			.help		= "Run the tests with program [procname]"
  		},
    {NULL, NULL, },
  };
  
  /*
   * This function registers the plugin_interface with DECAF.
   * The interface is used to register custom commands, let DECAF know which cleanup function to call upon plugin unload, etc,.
   */
  plugin_interface_t* init_plugin(void)
  {
    my_interface.mon_cmds = my_term_cmds;
    my_interface.plugin_cleanup = &my_cleanup;
    
    my_init();
    return (&my_interface);
  }
}}}

Now,you know the *plugin_cleanup* and *mon_cmds*. Let's talk about the sample plugin code. As you see, in the function *inint_plugin(void)*, we define our own command using *my_term_cmds*. In *my_term_cmds*, we specify the command name,command handler,command parameters and help message. You can define whatever you like following this convention. The *plugin_cleanup* is also defined by *my_cleanup*. Using *my_cleanup*, DECAF cleanup all the resources used by the plugin.

We put *my_init()*