
==3 Interfaces==
  
  DECAF provides many interfaces to make instrumentation easier. There are two kinds of interfaces.The first is callback for you to insert instrumentation code at specific event. Another set of interfaces is used as utils to get information of guest os or read memmory from guest OS. 

===3.1 Callback interfaces===

  To get a better understanding of these interfaces, a basic understanding of QEMU translation part is needed,please see [http://wiki.qemu.org/Manual qemu] for more details.

  1 *Callback types*

     * *Process callback types*
     it’s defined in /shared/procmod.h:procmod_callback_type_t

     ||PROCMOD_CREATEPROC_CB||  invoked when eprocess structure is created|| 
     ||PROCMOD_REMOVEPROC_CB|| invoked when delete the process||
     ||PROCMOD_PROCESSEND_CB|| alias of PROCMOD_REMOVEPROC_CB||
     ||PROCMOD_LOADMODULE_CB|| invoked when dll or driver is loaded||
     ||PROCMOD_LOADMAINMODULE_CB|| invoked when process starts to run||
     ||PROCMOD_PROCESSBEGIN_CB|| alias of PROCMOD_LOADMAINMODULE_CB||
     
     * *Instruction callback types*
     it’s defined in  /shared/DECAF_callback_common.h:DECAF_callback_type_t
This callback instruments guest operating system  at instruction level.
 
   DECAF_BLOCK_BEGIN_CB : invoked at the start of the block.
 DECAF_BLOCK_END_CB: invoked at the end of the block.
 DECAF_INSN_BEGIN_CB: invoked before this instruction is executed
 DECAF_INSN_END_CB:invoked after this instruction is executed 

     * *Mem read/write callback*
it’s defined in  /shared/DECAF_callback_common.h:DECAF_callback_type_t

DECAF_MEM_READ_CB :invoked when the memory read operation has been done
 DECAF_MEM_WRITE_CB:invoked when the memory write operation has been done

     * *Keystroke callback*

it’s defined in  /shared/DECAF_callback_common.h:DECAF_callback_type_t
DECAF_KEYSTROKE_CB:invoked when system read a keystroke from ps2 driver.
  
     * *EIP check callback*
 DECAF_EIP_CHECK_CB: for every function call, it will invoked this callback before it jump to target function specified by EIP. This is used to check if this EIP is tainted when you specify some taint source. If it’s tainted, it usually means  exploit happens.

     * *network callback*
it’s defined in  /shared/DECAF_callback_common.h:DECAF_callback_type_t
DECAF_NIC_REC_CB:invoked when network card receives data.
DECAF_NIC_SEND_CB:invoked when network card sends data.
Currently, DECAF’s implementation of network callback is based on NE2000 network card. So, when you write plugins using network callback ,please use NE2000 network card when you start DECAF by specifying “-device ne2k_pci,netdev=mynet”.



  2 *Callback register/unregister function*
  
    To use above callback, you should firstly register callback. Before you unload your plugin, please make sure this callback is unregistered. Or it may cause unexpected crash.
   To register/unregister process callback types, you should use the following code:

   {{{
DECAF_Handle procmod_register_callback(procmod_callback_type_t cb_type,
                procmod_callback_func_t cb_func,
                int *cb_cond
                );

int procmod_unregister_callback(procmod_callback_type_t cb_type, DECAF_Handle handle);
}}}

   To register/unregister other callback types, you should use the following code:

{{{
DECAF_Handle DECAF_register_callback(
		DECAF_callback_type_t cb_type,
		DECAF_callback_func_t cb_func,
		int *cb_cond
                );

int DECAF_unregister_callback(DECAF_callback_type_t cb_type, DECAF_Handle handle);


}}}

   For block begin/end callback ,you can also use the following for a high performance.

{{{
DECAF_Handle DECAF_registerOptimizedBlockBeginCallback(
    DECAF_callback_func_t cb_func,
    int *cb_cond,
    gva_t addr,
    OCB_t type);

DECAF_Handle DECAF_registerOptimizedBlockEndCallback(
    DECAF_callback_func_t cb_func,
    int *cb_cond,
    gva_t from,
    gva_t to);

int DECAF_unregisterOptimizedBlockBeginCallback(DECAF_Handle handle);

int DECAF_unregisterOptimizedBlockEndCallback(DECAF_Handle handle);

}}}

  3 *API Hook interfaces* 

   DECAF provides interfaces to hook any api in guest os. You can find the detailed description of these interfaces in */DECAF/shared/hookapi.h*

   {{{
uintptr_t hookapi_hook_function_byname(
		const char *mod,
		const char *func,
		int is_global,
		target_ulong cr3,
		hook_proc_t fnhook,
		void *opaque,
		uint32_t sizeof_opaque);

void hookapi_remove_hook(uintptr_t handle);
uintptr_t
hookapi_hook_return(
               target_ulong pc,
               hook_proc_t fnhook, 
               void *opaque, 
               uint32_t sizeof_opaque
               );
uintptr_t
hookapi_hook_function(
               int is_global,
               target_ulong pc,
               target_ulong cr3,
               hook_proc_t fnhook, 
               void *opaque, 
               uint32_t sizeof_opaque
               );

   }}}

===3.2 Utils===
  As you see in the above code, you registered a *DECAF_INSN_BEGIN_CB* callback, but what can you do in your handler *my_insn_begin_callback*? The utils interfaces is supposed to help you get more about guest os.You can find these definitions in *DECAF/shared/DECAF_main.c/h*. Now,We make a short table for these utils.

  ||function name||description||
  ||gpa_t DECAF_get_phys_addr(CPUState* env, gva_t addr)||given a virtual address of guest os, get the corresponded physical address ||
  ||DECAF_errno_t DECAF_memory_rw(CPUState* env, uint32_t addr, void *buf, int len,int is_write)||help||
  ||DECAF_errno_t DECAF_memory_rw_with_cr3(CPUState* env, target_ulong cr3,gva_t addr, void *buf, int len, int is_write)||help|| 
  ||DECAF_errno_t DECAF_read_mem(CPUState* env, gva_t vaddr, int len, void *buf)||help||
  ||DECAF_errno_t DECAF_write_mem(CPUState* env, gva_t vaddr, int len, void *buf)||help||
  ||DECAF_errno_t DECAF_read_mem_with_cr3(CPUState* env, target_ulong cr3,gva_t vaddr, int len, void *buf)||help||
  ||DECAF_errno_t DECAF_write_mem_with_cr3(CPUState* env, target_ulong cr3,gva_t vaddr, int len, void *buf)||help||
  ||DECAF_get_page_access(CPUState* env, gva_t addr)||help||


  